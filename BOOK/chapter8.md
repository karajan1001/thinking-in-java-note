# 第八章 多态
面向对象三特征：`多态`，`继承`，`数据抽象`

## 8.1 再讨论向上转型
就算向上转型也会包含基类型的全部接口。

### 8.1.1 忘记对象类型
每种类型一个接口过于冗余，只保留基类接口可以大大减少需要打交道的接口。

## 8.2 转机

### 8.2.1 方法调用绑定
将方法和调用主体关联叫绑定，程序执行前就确定叫`前期绑定`，前期绑定效率更高，但是会影响灵活性。运行时方法才确定运行主体叫`后期绑定`。JAVA 中除了 `final`和`static`方法都是后期绑定。

### 8.2.2 产生正确的行为
传入参数，返回值都只与基类打交道。方法都通过后期绑定。

### 8.2.3 可扩展性
子类的子类依然可以使用之前的接口。多态将改变的事物与未变的事物分离开来。

### 8.2.4 缺陷：覆盖私有方法
私有方法为`final`方法，无法被重载。

### 8.2.5 缺陷：静态方法和域
静态方法是与类，而非单个对象关联的

## 8.3 构造器和多态
构造器都是静态方法。
### 8.3.1 构造器的调用顺序
1. 调用基类构造器。
2. 按生命顺序调用成员的初始化方法。
3. 调用类构造器主体。

### 8.3.2 继承与清理
销毁顺序和构造正好相反。

### 8.3.3 构造器内部的多态方法的行为
构造器内部调用方法，可能会在方法初始化之前完成导致出现不可预知错误，要尽量避免它。

（Python中似乎将构造器`__new__`和初始化`__init__`分离，可以避免这个问题）

## 8.4 协变返回类型
覆盖方法可以返回子类型，而不用强制转换成和被覆盖方法一样。
## 8.5 用继承进行设计
> 用集成表示行为间的差异，用字段表示状态上的变化。
### 8.5.1 纯继承和扩展
纯继承: 子类型的接口和基类完全一致，完全的`is-a`关系，一般都是明智的。
扩展继承：子类型的接口是基类的扩展，`is-like-a`关系，可能需要向下转型。
### 8.5.2 向下转型与运行时类型识别
```java
(type_a) b  // 强制将b转换成type_a 可能会报错。
```

## 8.6 总结

