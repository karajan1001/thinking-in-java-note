# 第十章 内部类

## 10.1 创建内部类
直接在内部定义和创建类即可。

## 10.2 链接到外部类
内部类拥有外部类的所有元素的访问权限。内部类中拥有外部类的引用。比如在迭代器中，内部类是迭代器，外部类是个队列。迭代器拥有队列元素的访问权限，迭代器自己控制迭代位置。

## 10.3 使用.this 与.new
需要生成对外部类的引用可以使用`.this`,如果要指定对象去创建内部类对象则需要`.new`来进行。对于静态内部类（嵌套类）则不会外部类对象的引用。

## 10.4 内部类与向上转型
内部类一样可以向上转型，而且可以将内部类设为`private`或者`proteced`隐藏实现。

## 10.5 在方法和作用域内的内部类
内部类也可以包含在方法中，或者方法内部

## 10.6 匿名内部类
匿名内部类的语法为在return 时候构造一个新接口。后面包含了接口的实现, 如果内部类要带参数，则在加入构造器中加入参数。如果要使用外部定义对象，则要求参数引用为`final`，这个方法也可以用于自定义匿名构造器
```java
interface A{
    ax = x;
}

public class B{
    public A getA(int x, final String y){
        return new A(x){
            // 匿名构造器
            {
                ay = y;
            }
        }
    }
}
```

### 10.6.1 再访工厂方法
匿名类版本的工厂方法。

## 10.7 嵌套类
如果不需要内部类对象与外围类对象之间有联系，可以将内部类申明为`static`这就是嵌套类。
1. 要创建嵌套类对象，并不需要通过外部类对象。
2. 不能从嵌套类对象中方为非静态的外部类对象。
3. 普通内部类不能有`static`数据和字段，也不能包含嵌套类。

### 10.7.1 接口内部的类
可以将测试代码放在嵌套类中，这样就能将编译后的测试代码和正式代码分离开。

### 10.7.2 从多层嵌套类中访问外部类的成员
内部类嵌套多层都能透明访问所有它锁嵌入的外围类中的所有成员
```java
class MNA{
    private void f(){}
    class A{
        private void g(){}
        public class B{
            void h(){
                f();
                g();
            }
        }
    }
}
```

## 10.8 为何需要内部类

> 每个内部类都能独立的继承自一个接口的实现，福偶一无论外围类是否已经集成了某个接口的实现，对内部类都没有影响。

对于接口来说多重继承不是难事，但是对于类来说，多重继承则难以通过非内部类的方式实现。除此以外，内部类还有一些便利

1. 内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外部类的状态独立（迭代器中常用）
2. 单个外部类中可以用多个不同内部类实现同一个接口。
3. 创建内部类对象的时刻不依赖与外部类创建。
4. 内部类并没有`is-a`关系，它是一个实体。

### 10.8.1 闭包和回调
> 闭包： 一个可调用对象，记录了一些信息，信息来自创建它的作用域。

内部类是面向对象的闭包。可以显示安全的回调功能。

### 10.8.2 内部类和控制框架
略

## 10.9 内部类的继承
继承自内部类要显示写出
```java
class A{
    class B{
    }
}
public class C extends A.B{
    
}

```
## 10.10 内部类可以被覆盖吗
和方法不同，内部类不会继承的子类中的方法被覆盖，会有两个类。
## 10.11 局部内部类
方法中的内部类和匿名内部类一样无法被外部引用，它比匿名内部类的优势在于：
1. 可以创建多个。
2. 可以覆写构造器。
## 10.12 内部类标识符
内部类生成的文件名用$隔开，匿名类的名称用数字表示.

```bash
Outer.class
Outer$Inner.class
Outer$1.class
```

## 10.13 总结


